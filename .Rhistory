out = list()
for (i in 1:nrow(sigma)){
mu_mult_bar = solve(sigma[ -i, -i], sigma[i , -i])
sigma_bar = sigma[i,i] - mu_mult_bar %*% sigma[-i , i]
out[[i]] = list('sigma'=sigma_bar, 'mu_mult'=mu_mult_bar)
}
return(out)
}
# Vores gibbssampler
Gibbs <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
covmat = get_cov(0.5)
Gibbs(covmat, c(0,0,1))
covmat = get_cov(0.5, n_sib = 1)
Gibbs(covmat, c(0,0,1, 1))
LTFH <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
devtools::document()
#' @param K The prevalance of trait
#' @param s_val The starting value of estimates
#' @param min_run The minimum amount of runs to do after burn in
#' @param all_est If TRUE return the value for each iteration after burn in
#' @return A vector containing LTFH estimate of liabilities of the form \cr
#' c(genetic_liability_subject, liability_subject, liability_parent1, \cr
#' liability_parent2, liability_sibling1, ..., liability_siblingN)
#' @examples
#' LTFH(get_cov(0.5, n_sib = 1), c(1, 1, 0, 0))
#export
LTFH <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
devtools::document()
#' @param K The prevalance of trait
#' @param s_val The starting value of estimates
#' @param min_run The minimum amount of runs to do after burn in
#' @param all_est If TRUE return the value for each iteration after burn in
#' @return A vector containing LTFH estimate of liabilities of the form \cr
#' c(genetic_liability_subject, liability_subject, liability_parent1, \cr
#' liability_parent2, liability_sibling1, ..., liability_siblingN)
#' @examples
#' LTFH(get_cov(0.5, n_sib = 1), c(1, 1, 0, 0))
#export
LTFH <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
@export
#' @param K The prevalance of trait
#' @param s_val The starting value of estimates
#' @param min_run The minimum amount of runs to do after burn in
#' @param all_est If TRUE return the value for each iteration after burn in
#' @return A vector containing LTFH estimate of liabilities of the form \cr
#' c(genetic_liability_subject, liability_subject, liability_parent1, \cr
#' liability_parent2, liability_sibling1, ..., liability_siblingN)
#' @examples
#' LTFH(get_cov(0.5, n_sib = 1), c(1, 1, 0, 0))
#' @export
LTFH <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
devtools::document()
library(genstats)
?LTFH
devtools::document()
devtools::document()
library(genstats)
?LTFH
cbind(c(1,2,3), c(3,4,5))
class(cbind(c(1,2,3), c(3,4,5)))
class(cbind("k" = c(1,2,3), "K" = c(3,4,5)))
GWAS <- function(G, y, ncores = 1, p = 0.05/1000000){
lm = big_univLinReg(X = G, y.train = y, ncores = ncores)
p_vals = predict(lm, log10 = FALSE)
causal_estimate = ifelse(p_vals <=p, 1, 0)
return(cbind(lm, p_vals, causal_estimate))
}
#' @param G A FBM with SNP data
#' @param y A vector containing targets for each position.
#' @param ncores Amount of cores to use
#' @param p The significance level standard is 0.05 with bonferroni correction
#' @return a matrix containing the slopes of each regression, \cr
#'  the standard errors of each slope \cr
#'  the t-scores associated with each slope. \cr
#'  the p-values for each slope \cr
#'  and a binary vector saying if the position is causal or not given p
#'  @export
GWAS <- function(G, y, ncores = 1, p = 0.05/1000000){
lm = big_univLinReg(X = G, y.train = y, ncores = ncores)
p_vals = predict(lm, log10 = FALSE)
causal_estimate = ifelse(p_vals <=p, 1, 0)
return(cbind(lm, p_vals, causal_estimate))
}
devtools::document()
library(genstats)
#' @param G A FBM with SNP data
#' @param y A vector containing targets for each position.
#' @param ncores Amount of cores to use
#' @param p The significance level standard is 0.05 with bonferroni correction
#' @return a matrix containing the slopes of each regression, \cr
#'  the standard errors of each slope \cr
#'  the t-scores associated with each slope. \cr
#'  the p-values for each slope \cr
#'  and a binary vector saying if the position is causal or not given p
#'  @export
GWAS <- function(G, y, ncores = 1, p = 0.05/1000000){
lm = big_univLinReg(X = G, y.train = y, ncores = ncores)
p_vals = predict(lm, log10 = FALSE)
causal_estimate = ifelse(p_vals <=p, 1, 0)
return(cbind(lm, p_vals, causal_estimate))
}
devtools::document()
?GWAS
devtools::document()
library(genstats)
devtools::document()
#' @param K The prevalance of trait
#' @param s_val The starting value of estimates
#' @param min_run The minimum amount of runs to do after burn in
#' @param all_est If TRUE return the value for each iteration after burn in
#' @return A vector containing LTFH estimate of liabilities of the form \cr
#' c(genetic_liability_subject, liability_subject, liability_parent1, \cr
#' liability_parent2, liability_sibling1, ..., liability_siblingN)
#' @examples
#' LTFH(get_cov(0.5, n_sib = 1), c(1, 1, 0, 0))
#' @export
LTFH <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
devtools::document()
#' Calculate phenotypes
#'
#' @param l_e_0 vector containing enviromental liabilities
#' @param l_g_0 vector containing genetic liabilities
#' @param k prevalance of trait
#' @return binary vector contatining phenotypes
#' @export
y_func = function(l_e_0, l_g_0, K=0.05) {
l_0 = l_g_0 + l_e_0
T_ = qnorm(1-K)
y = ifelse(l_0>=T_, 1, 0)
return(y)
}
devtools::document()
?genstats::LTFH
#' @param covmat The covariance matrix
#' @param N Amount of rows in the matrix that the estimations are saved in
#' @param K The prevalance of trait
#' @param s_val The starting value of estimates
#' @return A vector containing LTFH estimate of liabilities of the form \cr
#' c(genetic_liability_subject, liability_subject, liability_parent1, \cr
#' liability_parent2, liability_sibling1, ..., liability_siblingN)
#' @examples
#' LTFH(get_cov(0.5, n_sib = 1))
#' @export
LTFH_notrunc <- function(covmat, N=3000, K = 0.05, s_val = 0){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
mu_vec = matrix(s_val, nrow = N-1, ncol = k)
current_liabil = rep(s_val, k)
for (i in 1:(N)) {
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult = const_list[[j]]$mu_mult
mu = mu_mult %*% current_liabil[-j] # Udelukker den liability vi er kommet til
mu_vec[i,j] = mu
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
liabil[i,] = current_liabil
}
return(list('liabilities'=liabil, 'mu'=mu_vec))
}
library(devtools)
document()
#' Puts a postfix into a vector of names
#'
#' @param names a vector containing 1 or more strings
#' @param n_sib the amount of siblings
#' @param id, if TRUE will add names for subject
#' @param parents if TRUE will add names for parents
#' @return a vector containing the postfix for each family member
#' @examples
#' get_names(c("l_g", l_e), n_sib = 1)
get_names <- function(names, n_sib=0, id= TRUE, parents=TRUE){
len = length(names)
prefix = c(rep("", len*id), rep("p",len*2*parents), rep("s",n_sib*len))
n_peop = 1*id + 2*parents + n_sib
index = c(rep(0,id), rep(c(1:2),parents), rep(c(3:(2+n_sib)),n_sib!=0))
name = rep("", len*(n_peop))
j = 1
for (i in 1:n_peop){
name[j:(j+len-1)] = paste0((paste(names,prefix[j:(j+len-1)], sep="_")), rep(index[i], len))
j = j + len
}
return(name)
}
document()
document()
library(genstats)
examples("get_names")
example("get_names")
?get_names
example(get_names)
get_names("l_g")
@export
#' Puts a postfix into a vector of names
#'
#' @param names a vector containing 1 or more strings
#' @param n_sib the amount of siblings
#' @param id, if TRUE will add names for subject
#' @param parents if TRUE will add names for parents
#' @return a vector containing the postfix for each family member
#' @examples
#' get_names(c("l_g", l_e), n_sib = 1)
#' @export
get_names <- function(names, n_sib=0, id= TRUE, parents=TRUE){
len = length(names)
prefix = c(rep("", len*id), rep("p",len*2*parents), rep("s",n_sib*len))
n_peop = 1*id + 2*parents + n_sib
index = c(rep(0,id), rep(c(1:2),parents), rep(c(3:(2+n_sib)),n_sib!=0))
name = rep("", len*(n_peop))
j = 1
for (i in 1:n_peop){
name[j:(j+len-1)] = paste0((paste(names,prefix[j:(j+len-1)], sep="_")), rep(index[i], len))
j = j + len
}
return(name)
}
?get_names
#' Adds a postfix to given names for each family member
#' @param names Names of the the values to add a postfix to e.g. l_g
#' @param n_sib Amount of siblings
#' @param id If TRUE add a postfix for the subject
#' @param parents If TRUE add postfix for parents
#' @return A vector containing the names for each family member
#' @examples
#' get_names(c("l_g", "l_e"), n_sib = 2)
#' @export
get_names <- function(names, n_sib=0, id= TRUE, parents=TRUE){
len = length(names)
prefix = c(rep("", len*id), rep("p",len*2*parents), rep("s",n_sib*len))
n_peop = 1*id + 2*parents + n_sib
index = c(rep(0,id), rep(c(1:2),parents), rep(c(3:(2+n_sib)),n_sib!=0))
name = rep("", len*(n_peop))
j = 1
for (i in 1:n_peop){
name[j:(j+len-1)] = paste0((paste(names,prefix[j:(j+len-1)], sep="_")), rep(index[i], len))
j = j + len
}
return(name)
}
document()

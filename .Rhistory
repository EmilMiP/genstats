#' this is another function
#' @return x + 3
#' @export
plus_three <- function(x){
x + 3
}
devtools::document()
library(devtools)
document
document()
document()
cov
document()
library(genstats)
?get_cov
#' Create covariance matrix
#'
#' @param h2 The heritability
#' @param n_sib Amount of siblings
#' @return Covariance matrix
#' @examples
#' gev_cov(0.5, n_sib = 2)
#' @export
get_cov <- function(h2, n_sib = 0) {
cov <- matrix(h2/2, 4 + n_sib, 4 + n_sib)
diag(cov) <- 1
cov[3,4] <- cov[4,3] <- 0
cov[1:2, 1] <- cov[1, 1:2] <- h2
cov
}
devtools::document()
library(genstats)
?get_cov
?get_cov
get_cov(0.5, n_sib = 2)
#' Create covariance matrix
#'
#' @param h2 The heritability
#' @param n_sib Amount of siblings
#' @return Covariance matrix
#' @examples
#' get_cov(0.5, n_sib = 2)
#' @export
get_cov <- function(h2, n_sib = 0) {
cov <- matrix(h2/2, 4 + n_sib, 4 + n_sib)
diag(cov) <- 1
cov[3,4] <- cov[4,3] <- 0
cov[1:2, 1] <- cov[1, 1:2] <- h2
cov
}
devtools::document()
library(genstats)
?get_cov
calc_distribution = function(sigma){
out = list()
for (i in 1:nrow(sigma)){
mu_mult_bar = solve(sigma[ -i, -i], sigma[i , -i])
sigma_bar = sigma[i,i] - mu_mult_bar %*% sigma[-i , i]
out[[i]] = list('sigma'=sigma_bar, 'mu_mult'=mu_mult_bar)
}
return(out)
}
document()
#' Calculates the parameters for the conditional distribution belonging to each
#' liabilities of the multivariate gaussian. Of the form
#' mu_mult = \eqn{\Sigma _{12}\Sigma _{22}^{-1}\mu _2}
#' sigma_bar = \eqn{\Sigma_11 - \Sigma _{12}\Sigma _{22}^{-1}\Sigma_21}
#' It is used as a helper function for LTFH
#' @param sigma The covariance matrix
#' @return a list containing sigma_bar and mu_mult for each liability
#' @examples calc_distribution(get_cov(0.5))
#' @export
calc_distribution = function(sigma){
out = list()
for (i in 1:nrow(sigma)){
mu_mult_bar = solve(sigma[ -i, -i], sigma[i , -i])
sigma_bar = sigma[i,i] - mu_mult_bar %*% sigma[-i , i]
out[[i]] = list('sigma'=sigma_bar, 'mu_mult'=mu_mult_bar)
}
return(out)
}
document()
library(genstats)
?calc_distribution
devtools::document()
library(genstats)
?calc_distribution
devtools::document()
library(genstats)
?calc_distribution
devtools::document()
library(genstats)
?calc_distribution
@export
#' liabilities of the multivariate gaussian.
#'
#' Of the form \cr
#' mu_mult = \eqn{\Sigma_{12}\Sigma_{22}^{-1}\mu _2} \cr
#' sigma_bar = \eqn{\Sigma_{11} - \Sigma_{12}\Sigma_{22}^{-1}\Sigma_{21}} \cr
#' It is used as a helper function for LTFH
#' @param sigma The covariance matrix
#' @return a list containing sigma_bar and mu_mult for each liability
#' @examples calc_distribution(get_cov(0.5))
#' @export
calc_distribution = function(sigma){
out = list()
for (i in 1:nrow(sigma)){
mu_mult_bar = solve(sigma[ -i, -i], sigma[i , -i])
sigma_bar = sigma[i,i] - mu_mult_bar %*% sigma[-i , i]
out[[i]] = list('sigma'=sigma_bar, 'mu_mult'=mu_mult_bar)
}
return(out)
}
devtools::document()
library(genstats)
?calc_distribution
?calc_distribution
?get_cov
library(bigsnpr)
library(dplyr)
library(ggplot2)
library(bigsnpr)
library(dplyr)
library(ggplot2)
get_cov = function(h2, n_sib = 0) {
cov <- matrix(h2/2, 4 + n_sib, 4 + n_sib)
diag(cov) <- 1
cov[3,4] <- cov[4,3] <- 0
cov[1:2, 1] <- cov[1, 1:2] <- h2
cov
}
calc_distribution = function(sigma){
out = list()
for (i in 1:nrow(sigma)){
mu_mult_bar = solve(sigma[ -i, -i], sigma[i , -i])
sigma_bar = sigma[i,i] - mu_mult_bar %*% sigma[-i , i]
out[[i]] = list('sigma'=sigma_bar, 'mu_mult'=mu_mult_bar)
}
return(out)
}
# Vores gibbssampler
Gibbs <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
covmat = get_cov(0.5)
Gibbs(covmat, c(0,0,1))
covmat = get_cov(0.5, n_sib = 1)
Gibbs(covmat, c(0,0,1, 1))
LTFH <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
devtools::document()
#' @param K The prevalance of trait
#' @param s_val The starting value of estimates
#' @param min_run The minimum amount of runs to do after burn in
#' @param all_est If TRUE return the value for each iteration after burn in
#' @return A vector containing LTFH estimate of liabilities of the form \cr
#' c(genetic_liability_subject, liability_subject, liability_parent1, \cr
#' liability_parent2, liability_sibling1, ..., liability_siblingN)
#' @examples
#' LTFH(get_cov(0.5, n_sib = 1), c(1, 1, 0, 0))
#export
LTFH <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
devtools::document()
#' @param K The prevalance of trait
#' @param s_val The starting value of estimates
#' @param min_run The minimum amount of runs to do after burn in
#' @param all_est If TRUE return the value for each iteration after burn in
#' @return A vector containing LTFH estimate of liabilities of the form \cr
#' c(genetic_liability_subject, liability_subject, liability_parent1, \cr
#' liability_parent2, liability_sibling1, ..., liability_siblingN)
#' @examples
#' LTFH(get_cov(0.5, n_sib = 1), c(1, 1, 0, 0))
#export
LTFH <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
@export
#' @param K The prevalance of trait
#' @param s_val The starting value of estimates
#' @param min_run The minimum amount of runs to do after burn in
#' @param all_est If TRUE return the value for each iteration after burn in
#' @return A vector containing LTFH estimate of liabilities of the form \cr
#' c(genetic_liability_subject, liability_subject, liability_parent1, \cr
#' liability_parent2, liability_sibling1, ..., liability_siblingN)
#' @examples
#' LTFH(get_cov(0.5, n_sib = 1), c(1, 1, 0, 0))
#' @export
LTFH <- function(covmat, phenos, N=10000, K = 0.05, s_val = 0, min_run=400, all_est=FALSE){
k = nrow(covmat)
const_list = calc_distribution(covmat)
liabil = matrix(s_val, nrow = N, ncol = k) # i formen c(l_g, l, l_p1, l_p2)
current_liabil = rep(s_val, k)
start_run = 500
s = 0
p = 0
while(TRUE) {
p = p +1
for (i in 2:start_run) {
s = s + 1
for (j in 1:k) {
# Udregner parametre
sigma = const_list[[j]]$sigma
mu_mult_ = const_list[[j]]$mu_mult
mu = mu_mult_ %*% current_liabil[-j] # Udelukker den liability vi er kommet til
if (j == 1) {
current_liabil[j] = rnorm(1, mu, sqrt(sigma))
}
else {
crit <- qnorm(1-K)
crit_bound = pnorm(crit, mu, sqrt(sigma))
interval_2 = c(0, crit_bound)
interval_1 = c(crit_bound, 1)
phen = phenos[j-1]
interval = phen * interval_1 + (1-phen)*interval_2
U = runif(1,interval[1], interval[2])
current_liabil[j] = qnorm(U, mu, sqrt(sigma))
}
if(s > start_run){
liabil[i+start_run*(p-2),] = current_liabil
}
}
}
if(s>(start_run+min_run)){
end_val = s-start_run
if(sd(liabil[1:end_val,1])/sqrt(length(liabil[1:end_val,1])) < 0.1){
if (all_est){
return(liabil[1:end_val,])
}
return(colMeans(liabil[1:end_val,]))
}
}
}
}
devtools::document()
library(genstats)
?LTFH
devtools::document()
devtools::document()
library(genstats)
?LTFH
cbind(c(1,2,3), c(3,4,5))
class(cbind(c(1,2,3), c(3,4,5)))
class(cbind("k" = c(1,2,3), "K" = c(3,4,5)))
GWAS <- function(G, y, ncores = 1, p = 0.05/1000000){
lm = big_univLinReg(X = G, y.train = y, ncores = ncores)
p_vals = predict(lm, log10 = FALSE)
causal_estimate = ifelse(p_vals <=p, 1, 0)
return(cbind(lm, p_vals, causal_estimate))
}
#' @param G A FBM with SNP data
#' @param y A vector containing targets for each position.
#' @param ncores Amount of cores to use
#' @param p The significance level standard is 0.05 with bonferroni correction
#' @return a matrix containing the slopes of each regression, \cr
#'  the standard errors of each slope \cr
#'  the t-scores associated with each slope. \cr
#'  the p-values for each slope \cr
#'  and a binary vector saying if the position is causal or not given p
#'  @export
GWAS <- function(G, y, ncores = 1, p = 0.05/1000000){
lm = big_univLinReg(X = G, y.train = y, ncores = ncores)
p_vals = predict(lm, log10 = FALSE)
causal_estimate = ifelse(p_vals <=p, 1, 0)
return(cbind(lm, p_vals, causal_estimate))
}
devtools::document()
library(genstats)
#' @param G A FBM with SNP data
#' @param y A vector containing targets for each position.
#' @param ncores Amount of cores to use
#' @param p The significance level standard is 0.05 with bonferroni correction
#' @return a matrix containing the slopes of each regression, \cr
#'  the standard errors of each slope \cr
#'  the t-scores associated with each slope. \cr
#'  the p-values for each slope \cr
#'  and a binary vector saying if the position is causal or not given p
#'  @export
GWAS <- function(G, y, ncores = 1, p = 0.05/1000000){
lm = big_univLinReg(X = G, y.train = y, ncores = ncores)
p_vals = predict(lm, log10 = FALSE)
causal_estimate = ifelse(p_vals <=p, 1, 0)
return(cbind(lm, p_vals, causal_estimate))
}
devtools::document()
?GWAS
devtools::document()
library(genstats)
